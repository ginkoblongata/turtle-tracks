

add("RUN parses the given list as a sequence of Logo commands, and executes them. If the command list evaluates to a value, RUN returns that value, otherwise it returns nothing. If the argument is not a list, if the list cannot be parsed as a valid sequence of Logo commands, or if an error occurs while running the list, RUN throws an error.");
add("RUNRESULT parses the given list as a sequence of Logo commands, and executes them. If the command list returns a value, RUNRESULT returns a list with that value as the single element, otherwise it returns the empty list. If the argument is not a list, if the list cannot be parsed as a valid sequence of Logo commands, or if an error occurs while running the list, RUNRESULT throws an error.");
add("APPLY parses the given list as a lambda list, and executes it, creating a local scope and binding the formal arguments with the values given in the argslist. It returns the result of the invocation, or nothing if the lambda returns nothing. If the first argument is a normal lambda list, it executes it as a normal procedure-- that is, you must use the OUTPUT command to return a value, or the STOP command to exit in the middle without returning a value. If the first argument is a macro lambda list, it executes as a macro procedure-- that is, it evaluates directly, and if you call STOP or OUTPUT, it will exit the enclosing procedure. If the first argument is a word, it is interpreted as a procedure name, and that procedure is invoked. The second argument should be a list, whose elements are treated as the arguments to the function invocation. If the second argument is not a list, or the number of elements in the list given does not match the number of formal arguments in the lambda, APPLY throws an error.");
add("APPLYRESULT parses the first argument as a lambda list, and executes it, creating a local scope and binding the formal arguments with the values given in the argslist. It returns a list containing the result of the invocation as the single element, or the empty list if the lambda returns nothing. If the first argument is a normal lambda list, it executes it as a normal procedure-- that is, you must use the OUTPUT command to return a value, or the STOP command to exit in the middle without returning a value. If the first argument is a macro lambda list, it executes as a macro procedure-- that is, it evaluates directly, and if you call STOP or OUTPUT, it will exit the enclosing procedure. If the first argument is a word, it is interpreted as a procedure name, and that procedure is invoked. The second argument should be a list, whose elements are treated as the arguments to the function invocation. If the second argument is not a list, or the number of elements in the list given does not match the number of formal arguments in the lambda, APPLYRESULT throws an error.");
add("INVOKE parses the given list as a lambda list, and executes it, creating a local scope and binding the formal arguments with the values given. It returns the result of the invocation, or nothing if the lambda returns nothing. If the first argument is a normal lambda list, it executes it as a normal procedure-- that is, you must use the OUTPUT command to return a value, or the STOP command to exit in the middle without returning a value. If the first argument is a macro lambda list, it executes as a macro procedure-- that is, it evaluates directly, and if you call STOP or OUTPUT, it will exit the enclosing procedure. If the first argument is a word, it is interpreted as a procedure name, and that procedure is invoked. If the number of arguments given does not match the number of formal arguments in the lambda, INVOKE throws an error.");
add("INVOKERESULT parses the first argument as a lambda list, and executes it, creating a local scope and binding the formal arguments with the values given. It returns a list containing the result of the invocation as the single element, or the empty list if the lambda returns nothing. If the first argument is a normal lambda list, it executes it as a normal procedure-- that is, you must use the OUTPUT command to return a value, or the STOP command to exit in the middle without returning a value. If the first argument is a macro lambda list, it executes as a macro procedure-- that is, it evaluates directly, and if you call STOP or OUTPUT, it will exit the enclosing procedure. If the first argument is a word, it is interpreted as a procedure name, and that procedure is invoked. If the number of arguments given does not match the number of formal arguments in the lambda, INVOKERESULT throws an error.");
add("MAP parses the first argument as a lambda list, and executes it for each of the arguments given in the argument lists, creating a local scope and binding the formal arguments with the values given. It returns a list containing results of the invocation on each of the elements of the argument lists. If the first argument is a normal lambda list, it executes it as a normal procedure-- that is, you must use the OUTPUT command to return a value, or the STOP command to exit in the middle without returning a value. If the first argument is a macro lambda list, it executes as a macro procedure-- that is, it evaluates directly, and if you call STOP or OUTPUT, it will exit the enclosing procedure. If the first argument is a word, it is interpreted as a procedure name, and that procedure is invoked. If an invocation of the lambda does not return a value, that invocation is ignored during construction of the return list (i.e. the list returned from MAP is shorter.) If the number of argument lists given does not match the number of formal arguments in the lambda, the argument lists are not all of the same length, or the first argument is a procedure name that is not defined, MAP throws an error.");
add("FOREACH parses the last argument as a lambda list, and executes it for each of the arguments given in the argument lists, creating a local scope and binding the formal arguments with the values given. It does not return anything. If the first argument is a normal lambda list, it executes it as a normal procedure-- that is, you must use the OUTPUT command to return a value, or the STOP command to exit in the middle without returning a value. If the first argument is a macro lambda list, it executes as a macro procedure-- that is, it evaluates directly, and if you call STOP or OUTPUT, it will exit the enclosing procedure. If the first argument is a word, it is interpreted as a procedure name, and that procedure is invoked. If the number of argument lists given does not match the number of formal arguments in the lambda, the argument lists are not all of the same length, the last argument is a procedure name that is not defined, or the function returns a value, FOREACH throws an error.");

add("IF first evaluates the given expression. If it evaluates to \"TRUE, the given list is then parsed as a sequence of Logo commands and executed, otherwise the given list is ignored. IF never returns a value, even if the command list is executed and evaluates to a value. If expr does not evaluate to \"TRUE or \"FALSE, a non-list is given as an input, or if the list cannot be parsed as a valid sequence of Logo commands, or if an error occurs while running the list, IF throws an error.");
add("IFELSE first evaluates the given expression. If it evaluates to \"TRUE, list1 is then parsed as a sequence of Logo commands and executed, otherwise list2 is executed. If the executed list evaluates to a value, then IFELSE returns that value. If expr does not evaluate to \"TRUE or \"FALSE, a non-list is given as an input, or if the list cannot be parsed as a valid sequence of Logo commands, or if an error occurs while running the list, IFELSE throws an error. Note that IF can also behave in the same way as IFELSE by enclosing it in parentheses.");
add("TEST sets the current test value, which is used in subsequent IFTRUE and IFFALSE commands. If the given expression evaluates to \"TRUE then the test value is set to true. If the given expression evaluates to \"FALSE then the test value is set to false. If the given expression does not evaluate to \"TRUE or \"FALSE then TEST throws an error.  If the current test value set by TEST is true, the given list is parsed as a sequence of Logo commands and executed, otherwise the given list is ignored. IFTRUE never returns a value, even if the command list is executed and evaluates to a value. If there is no current test value, a non-list is given as an input, or if the list cannot be parsed as a valid sequence of Logo commands, or if an error occurs while running the list, IFTRUE throws an error.  If the current test value set by TEST is false, the given list is parsed as a sequence of Logo commands and executed, otherwise the given list is ignored. IFFALSE never returns a value, even if the command list is executed and evaluates to a value. If there is no current test value, a non-list is given as an input, or if the list cannot be parsed as a valid sequence of Logo commands, or if an error occurs while running the list, IFFALSE throws an error.");

add("REPEAT The given list is parsed as a sequence of Logo commands and executed the number of times specified by the given integer. REPEAT never returns a value, even if the command list evaluates to a value. If the first input is not a valid integer, a non-list is given as the second input, the list cannot be parsed as a valid sequence of Logo commands, or if an error occurs while running the list, REPEAT throws an error.");
add("REPCOUNT evaluates to the current iteration number in the innermost repeat loop. If invoked while not inside a repeat loop, REPCOUNT returns -1.");
add("The given condlist is parsed as a sequence of Logo commands. It must evaluate to a boolean value. As long as the condlist evaluates to true, the given cmdlist is parsed as a sequence of Logo commands and repeatedly executed. The cmdlist should not evaluate to a value. The condlist is evaluated first, so it is possible that the cmdlist will never execute. WHILE never returns a value. If either list cannot be parsed as a valid sequence of Logo commands, or if an error occurs while running either list, WHILE throws an error.");
add("The given condlist is parsed as a sequence of Logo commands. It must evaluate to a boolean value. Until the condlist evaluates to true, the given cmdlist is parsed as a sequence of Logo commands and repeatedly executed. The cmdlist should not evaluate to a value. The condlist is evaluated first, so it is possible that the cmdlist will never execute. UNTIL never returns a value. If either list cannot be parsed as a valid sequence of Logo commands, or if an error occurs while running either list, UNTIL throws an error.");
add("The given condlist is parsed as a sequence of Logo commands. It must evaluate to a boolean value. As long as the condlist evaluates to true, the given cmdlist is parsed as a sequence of Logo commands and repeatedly executed. The cmdlist should not evaluate to a value. The cmdlist is evaluated first, so it will always execute at least once. DO.WHILE never returns a value. If either list cannot be parsed as a valid sequence of Logo commands, or if an error occurs while running either list, DO.WHILE throws an error.");
add("The given condlist is parsed as a sequence of Logo commands. It must evaluate to a boolean value. Until the condlist evaluates to true, the given cmdlist is parsed as a sequence of Logo commands and repeatedly executed. The cmdlist should not evaluate to a value. The cmdlist is evaluated first, so it will always execute at least once. DO.UNTIL never returns a value. If either list cannot be parsed as a valid sequence of Logo commands, or if an error occurs while running either list, DO.UNTIL throws an error.");
add("The given control list should be of the form [varname start end step]. A new symbol level is created on the stack, and the given varname is declared local and set to start. As long as the variable has not gone past end, the given cmdlist is run, and then the variable is changed by step. If there are only three elements in the control list, the step is assumed to be 1. The cmdlist should not evaluate to a value. Going "past" end means, more precisely, var&gt;end if step&gt;0, or var&lt;end if step&lt;0. Note that a new symbol level is created within the loop, so any variables declared local within the loop will not exist outside the scope of the loop. FOR never returns a value. If the control list is invalid, the cmdlist list cannot be parsed as a valid sequence of Logo commands, or if an error occurs while running it, FOR throws an error.");
add("Turtle Tracks provides a simple yet powerful set of multitasking tools using threads. These threads share the same global names, procedures, property lists and open streams, but have separate call stacks and current I/O settings. Turtle Tracks threads are pre-emptive and time-sliced; however, all workspace manipulation primitives and i/o functions are guaranteed to be atomic. In addition, a small library of synchronization primitives is provided.");
add("THREAD executes the given command list or lambda in a new thread. It generates a unique id for the new thread, and the new thread runs concurrently with the current thread. THREAD does not return a value. If the command input is a lambda list or a procedure or primitive name, then the arguments are given to the thread as local variables in the toplevel scope. If the given command input is not a command list, a well-formed lambda list, or a procedure or primitive name, or the given argslist is not a list, THREAD throws an error. If an error occurs while parsing or executing the command list, THREAD returns normally and an error is thrown within the new thread.");
add("THREADRUN executes the given command list in a new thread. If a threadid is specified, THREADRUN gives the new thread that id; otherwise THREADRUN generates a unqiue threadid for the thread. In either case, THREADRUN does not return any value. The new thread runs concurrently with the current thread. If the given command input is not a command list or the given threadid is not a word, THREADRUN throws an error. If an error occurs while parsing or executing the command list, THREADRUN returns normally and an error is thrown within the new thread.");
add("THREADRUNID executes the given command list in a new thread. If a threadid is specified, THREADRUNID gives the new thread that id; otherwise THREADRUNID generates a unqiue threadid for the thread. In either case, THREADRUNID returns the id of the new thread. The new thread runs concurrently with the current thread. If the given command input is not a command list or the given threadid is not a word, THREADRUN throws an error. If an error occurs while parsing or executing the command list, THREADRUN returns normally and an error is thrown within the new thread.");
add("THREADAPPLY executes the given lambda in a new thread. If a threadid is specified, THREADAPPLY gives the new thread that id; otherwise, THREADAPPLY generates a unqiue threadid for the thread. In either case, THREADAPPLY returns nothing. The new thread runs concurrently with the current thread. The arguments are given to the thread as local variables in the toplevel scope. If the given command input is not a well-formed lambda list or a procedure or primitive name, the given argslist is not a list, or the given threadid is not a word, THREADAPPLY throws an error. If an error occurs while parsing or executing the lambda, THREADAPPLY returns normally and an error is thrown within the new thread.");
add("THREADAPPLYID executes the given lambda in a new thread. If a threadid is specified, THREADAPPLYID gives the new thread that id; otherwise, THREADAPPLYID generates a unqiue threadid for the thread. In either case, THREADAPPLYID returns the id of the new thread. The new thread runs concurrently with the current thread. The arguments are given to the thread as local variables in the toplevel scope. If the given command input is not a well-formed lambda list or a procedure or primitive name, the given argslist is not a list, or the given threadid is not a word, THREADAPPLYID throws an error. If an error occurs while parsing or executing the lambda, THREADAPPLYID returns normally and an error is thrown within the new thread.");
add("THREADTERMINATE stops the thread with the given id, by throuwing a .SUDDENSTOPTHREAD exception within the thread. If no running thread has the given id, THREADTERMINATE does nothing. If the given threadid is not a word, THREADTERMINATE throws an error. Note that the .SUDDENSTOPTHREAD exception may be caught by the thread being terminated, if it needs to perform any clean-up. If this is done, the thread MUST rethrow the exception.");
add("CURRENTTHREAD returns the threadid of the currently running thread. The main thread is given the name \".MAIN\" by the Logo runtime system.");
add("CRITICAL runs the given runnable list in a critical section with the given name. Only one thread at a time can be running a critical section with a particular name. When CRITICAL is encountered, if another thread is already running a CRITICAL section with that name, CRITICAL will block until the other thread has finished running its list. If the given critical section id is not a word, or the second argument cannot be parsed as a runnable list, CRITICAL throws an error.");
add("BARRIER defines a barrier with the given name and thread count. BARRIER blocks until the given number of threads have called BARRIER with that name. Once a barrier becomes unblocked, the count is reset to zero; therefore, a barrier can be re-used. If the given barrierid is not a word, the given thread count is not an integer, or the given thread count does not match the thread counts given by other concurrent calls to BARRIER with the same barrier id, then BARRIER throws an error.");
add("Logo provides error handling similar to C++ or Tcl exceptions.");
add("THROW causes an exception with the given tag word to be thrown. If a value is specified, that value is thrown with the exception, and can be retrieved by an enclosing CATCH or TRY command. If the given tag is not a word, THROW instead throws an error.");
add("CATCH executes the given command list. If an exception of the same id as the given tag is thrown while executing the command list, CATCH will \"catch\" the exception, and it will not propogate any further out. If the given tag is a word, it is interpreted as a single tag word. If it is a list, the elements of the list are interpreted as the tag words to catch. If the given tag is the empty list [], it is treated as a wildcard and will catch any exception. If the command list evaluates to a value and does not throw an exception, then CATCH will return that value. If an exception is thrown with an accompanying value, CATCH returns that value. If the command list does not evaluate to a value, or an exception is thrown without an accompanying value, CATCH returns nothing. If a non-list is given as the command list input, or if the tag list contains non-word elements, CATCH throws an error. If the input is a list but cannot be parsed as a valid sequence of Logo commands, CATCH will behave as if an error were thrown out of the command list.");
add("TRY executes the given command list. If an exception of the same id as any of the given tags is thrown, TRY will \"catch\" the exception, and it will not propogate any further out. If the given tag is a word, it is interpreted as a single tag word. If it is a list, the elements of the list are interpreted as the tag words to catch. If the given tag is the empty list [], it is treated as a wildcard and will catch any exception. Furthermore, TRY will excute the catchcmdlist associated with the caught tag. The catchcmdlist may be a command list or a lambda. If it is a lambda, it must take two arguments, which are bound to the caught exception and the associated value.");
add("If the command list evaluates to a value and does not throw an exception, then TRY will return that value. If an exception is thrown and caught, and the command list associated with the caught exception evaluates to a value (or if it is a non-macro lambda and outputs a value), TRY returns that value. If no command list executed evaluates to a value, TRY returns nothing. If a non-list is given as the command list input, or if the given tag list contains non-word members, TRY throws an error. If the input is a list but cannot be parsed as a valid sequence of Logo commands, TRY will behave as if an error were thrown out of the command list. The version of TRY enclosed by parens may include any number of tags to catch. Each tag, however, must be accompanied by a command list-- that is, TRY must take an odd number of inputs. If an even number of inputs is given to TRY, it will throw an error.");
add("Jump commands cause an immediate jump to some point outside the current scope. Jump commands are actually implemented as throws; thus each jump has an equivalent THROW command associated with it. Because of this, jumps may also be caught to prevent their normal completion.");
add("TOPLEVEL causes all interpreter activity to cease, and control to be given back to the Logo console. This includes all running threads. First, the current thread is terminated by propogating the exception to the top of the thread. Once the current thread has been stopped, all other threads are killed. If a TOPLEVEL is caught and does not propogate to the top of the current thread, any other running threads are left intact.");
add("STOPTHREAD terminates the current thread by propogating the exception to the top of the thread. No other threads are affected. If the current thread is the only running thread, then control is returned to the Logo console.");
add("OUTPUT causes the innermost executing procedure to stop execution and produce as a return value the given expression. Note that the associated THROW tag is "STOP.");
add("STOP causes the innermost executing procedure to stop execution and not generate a return value.");
add("GOODBYE exits the Logo runtime environment. This includes shutting down all running threads and closing down any user interface elements. First, the current thread is terminated by propogating the exception to the top of the thread. Once the current thread has been stopped, all other threads are killed. If a GOODBYE is caught and does not propogate to the top of the current thread, the other running threads are left intact and the runtime environment is not terminated.");
